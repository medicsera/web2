# Лабораторная работа №2
## Spring boot. ~~Возвращение джедая~~ Начало

---

## Необходимый софт для выполнения задания

- IntelliJ IDEA CE или аналоги ([OpenIDE](https://openide.ru/), [GigaIDE](https://gitverse.ru/features/gigaide/))
- Плагин для работы со Spring проектами [Amplicode](https://amplicode.ru/).
- JDK 21 / JDK 17
- Kotlin
- [Postman](https://www.postman.com/)
- [Bruno](https://docs.usebruno.com/)

PS: Вы можете использовать любую другую IDE, но тогда вам придется самостоятельно разобраться в том как это все работает ^_^
PPS: Вы также можете выбрать сборщик (Gradle/Maven). На данном этапе это не имеет значения

---

## Теоретическая часть

Здесь мы рассмотрим процесс создания простого REST API с использованием фреймворка **Spring Boot**.  
Мы создадим 1 эндпоинт и проведем тестирование его работоспособности через различные инструменты.


### Создание проекта Spring Boot + Kotlin

1. Открываем IDE и создаем новый проект  
![Тут должно быть изображение](./.assets/img/creating-screen.png)  
По умолчанию сборщик - Maven, так и оставляем, язык **Kotlin**.  
Откроется созданный проект. структура должна быть примерно следующей:  
![Тут должен быть скрин](./.assets/img/start-screen.png)  

2. Далее откроем файл конфигурации `pom.xml`. Нужно будет добавить несколько зависимостей в проект
```xml

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<dependency>
    <groupId>tools.jackson.module</groupId>
    <artifactId>jackson-module-kotlin</artifactId>
</dependency>
```

3. Далее запустим приложение (хоть пока ничего нет, мы должны проверить работоспособность). Сделать это можно нажав 
   на зелененькую стрелочку слева от метода main или выполнив команду из терминала
```shell
./mvnw spring-boot:run
```
или
```shell
./mvnw clean package

java -jar target/*-SNAPSHOT.jar
```
Если файл `./mvnw` или `./mvnw.cmd` отсутствует, то попробуйте выполнить ```mvn wrapper:wrapper```

Если все работает - **ОТЛИЧНО!**

4. Далее создадим контроллер для первого эндпоинта в пакете `controller`.  
![Тут должен быть скриншот](./.assets/img/create-controller.png)  

5. В файле контроллера напишем следующий код:
```kotlin
@RestController
@RequestMapping("/greeting")
class HelloController {

    @GetMapping
    fun hello(): String {
        return "Hello World"
    }
}
```
И проверим работу приложения. Запускается по той же схеме, что выше.  
После запуска перейдите по ссылке `http://localhost:8080/greeting` в браузере.  
Если в браузере вы увидели `Hello World` - значит все сделали правильно.

6. Далее сделаем косметические улучшения в коде.  
Добавим дата-класс в новый пакет `dto`
```kotlin
data class GreetingMain(
    val text: String = "Hello World"
)
```
И теперь будем вместо `String` возвращать объект этого класса.
```kotlin
@RestController
@RequestMapping("/greeting")
class HelloController {

    @GetMapping
    fun hello(): GreetingMain {
        return GreetingMain()
    }
}
```


### Технологии тестирования REST API
В данном разделе мы рассмотрим различные технологии для тестирования работоспособности rest api.

#### 1. Самый простой способ - `curl`. Наш эндпоинт из примера выше тестируется простейшей командой:
```shell
curl http://localhost:8080/greeting
```
или для подробного вывода:
```shell
curl -v http://localhost:8080/greeting
```
ну или более сложные запросы:
```shell
# POST с JSON
curl -X POST http://localhost:8080/api/v1/users \
  -H "Content-Type: application/json" \
  -d '{"name": "John", "email": "john@mail.com"}'

# С авторизацией
curl -H "Authorization: Bearer eyJhbG..." \
  http://localhost:8080/api/v1/users
```

#### 2. Postman / Bruno.  
Postman и Bruno — это графические инструменты для отправки HTTP-запросов к API. Они позволяют легко формировать GET, 
   POST, PUT, DELETE запросы с нужными заголовками и телом, видеть ответ сервера, сохранять запросы в коллекции и использовать переменные окружения.  
Главное отличие: `Postman` хранит коллекции в облаке, а `Bruno` — в виде текстовых файлов прямо в проекте, что 
   удобно для Git.  
Далее здесь будет продемонстрирован пример работы с `Bruno`. Для Postman действия аналогичные, за исключением пары 
   нюансов.  

- Для начала создадим рабочее пространство:  
![Тут должен быть скриншот](./.assets/img/bruno-workspace.png)  
- В созданном рабочем пространстве создадим коллекцию запросов (Формат делайте `yaml`):  
![Тут должен быть скриншот](./.assets/img/bruno-collection.png)  
- Далее создадим окружение для рабочего пространства. Тут мы сможем хранить константы (url-ки, токены и тд):  
![Тут должен быть скриншот](./.assets/img/bruno-environment.png)  
- В переменную окружения запишем url приложения и сохраняем:  
![Тут должен быть скриншот](./.assets/img/bruno-base-url.png)  
- Теперь вы можете использовать переменную окружения для составления запросов:  
![Тут должен быть скриншот](./.assets/img/bruno-request.png)  
- Теперь запрос можно выполнить и проверить работоспособность эндпоинта с помощью удобного ~~нет~~ интерфейса:  
![Тут должен быть скриншот](.assets/img/bruno-executed-request.png)    

Ну вот допустим вы сделали запрос и запустили его. Но вот вам нужно проверить, что статус код именно такой как вам нужно (не 201, не 300, не 400 и тд). Как тогда поступить? Ведь если вам нужен код ошибки (негативное тестирование), то бруно посчитает, что запрос выполнился некорректно.  
Тут на помощь приходят скрипты для запросов. С их помощью можно провести тестирование результатов запроса:  
- В окне запроса откроем вкладку `Script` -> `Post Response` и напишем следующий скрипт на проверку статус кода и наличия поля в json ответа:  
```js
test("Статус ответа должен быть 200", function() {
  expect(res.status).to.equal(200);
});

test("Поле 'text' существует и не является пустым", function() {
  const data = res.body;
  
  // Проверяем, что поле существует (не undefined)
  expect(data).to.have.property("text");
  
  // Проверяем, что это строка
  expect(data.text).to.be.a('string');
  
  // Проверяем, что длина строки больше 0
  expect(data.text.length).to.be.greaterThan(0);
});
```
- Затем запустим запрос и увидим вкладку `Tests` у результата запроса. Если вы сделали все правильно, то оба теста будут зелеными:  
![Тут должен быть скриншот](./.assets/img/bruno-test-result.png)  

#### 3. Connekt  
Следующий инструмент для тестирования апи - `Connekt`. Поставляется он вместе с плагином `Amplicode` и работает на kotlin. Чтобы создать тест-скрипт, сделаем новую директорию в репозитории и назовем ее `.requests`, там средствами IDE создадим connekt-скрипт. По-умолчанию там уже содержится примерный код. Если код подсвечивается красным, перезагрузите IDE, обычно это помогает.  

- Для начала удалим примерный код и напишем следующий для тестирования нашего эндпоинта:  
```kotlin
GET("http://localhost:8080/greeting") {
    accept("application/json")
} then {
    Assertions.assertThat(code).isEqualTo(200)
}
```

- Каждый раз писать url неудобно, поэтому тут как и в Postman/Bruno есть механизм окружений. Чтобы создать окружение, нажмем `Create environment` ^-^  
![Тут должен быть скриншот](./.assets/img/connekt-create-environment.png)
- В созданном файле добавим переменную окружения:
```json
{
  "local": {
    "baseUrl": "http://localhost:8080"
  }
}
```
- Теперь можно использовать переменную окружения в скрипте:
```kotlin
val baseUrl: String by env
val path = "greeting"

GET("$baseUrl/$path") {
    accept("application/json")
} then {
    Assertions.assertThat(code).isEqualTo(200)
}
```
- Также если возникают затруднения, можно ознакомиться с примерами, прямо в IDE:  
![Тут должен быть скриншот](.assets/img/connekt-examples.png)

---

## Задание
Используя этот репозиторий в качестве шаблона, выполните следующие задания.

1. В соответствии со спецификацией, определенной в файле `specs.yaml`, добавьте недостающие эндпоинты в контроллер. Обратите внимание, что первый эндпоинт имеет разное поведение в зависимости от наличия параметра запроса.
2. Проведите тестрование рассмотренными ранее средствами (Bruno, Connekt, Postman (экспортируйте в json)):
   - В каждом инструменте проведите тестирование всех эндпоинтов. 
   - Url храните в переменных среды.
   - Сделайте проверку сохранения пользователя (сохраняйте id пользователя после пост запроса, потом отправляйте его)

---

## PS
Файлы, которые уже лежат в репозитории `не изменяйте`

---

## Таблица критериев оценки

| Категория                      | Критерий                 | Описание                                                                                                                  |  Баллы  |
|:-------------------------------|:-------------------------|:--------------------------------------------------------------------------------------------------------------------------|:-------:|
| **Штрафы**                     | **Существующие тесты**   | Если не проходят существующие Unit-тесты (которые были в шаблоне)                                | **-10** |
|                                |                          |                                                                                                                           |         |
| **1. API (10 баллов)**         | **Спецификация OpenAPI** | Все эндпоинты реализованы строго по файлу `specs.yaml` (правильные URL, методы, коды ответов, поля JSON).                 |  **4**  |
|                                | **Логика GET /greeting** | Корректно реализовано разделение логики: запрос без параметров возвращает приветствие, запрос с `?id=` ищет пользователя. |  **4**  |
|                                | **Бизнес-логика**        | Корректная генерация UUID при создании, сохранение в переменную, возврат 404 при отсутствии пользователя.                 |  **2**  |
|                                |                          |                                                                                                                           |         |
| **2. Тестирование (9 баллов)** | **Postman**              | 1. Коллекция экспортирована в JSON.<br>2. URL вынесен в переменные окружения.<br>3. Реализован сценарии.                  |  **3**  |
|                                | **Bruno**                | 1. Файлы коллекции присутствуют.<br>2. URL в переменных окружения.<br>3. Реализованы сценарии.                            |  **3**  |
|                                | **Connekt**              | 1. Файлы/Конфиг присутствуют.<br>2. URL в переменных окружения.<br>3. Реализованы сценарий.                               |  **3**  |
|                                |                          |                                                                                                                           |         |
| **3. Оформление (1 балл)**     | **Культура кода**        | Чистота кода, отсутствие лишних файлов в репозитории (правильный `.gitignore`), тесты лежат в папке `tests/`.             |  **1**  |
|                                |                          |                                                                                                                           |         |
| **ИТОГО**                      |                          | **Максимальный балл**                                                                                                     | **20**  |

---

## Что почитать?
- [Swagger](https://swagger.io/tools/swagger-editor/)
- [Spring boot Rest](https://spring.io/guides/tutorials/rest)
- [OpenIDE](https://openide.ru/download)
- [Amplicode](https://amplicode.ru/)
- [Connekt обзор](https://habr.com/ru/companies/domclick/articles/965116/)
- [Bruno docs](https://docs.usebruno.com/)
- [Postman docs](https://learning.postman.com/docs/introduction/overview)